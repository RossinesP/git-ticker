# GitLab Ticker

A Python project for tracking and analyzing GitLab repositories using Domain-Driven Development (DDD) architecture.

## Overview

GitLab Ticker is designed to provide tools and services for working with GitLab repositories, including validation utilities and analysis capabilities. The project follows a clean architecture pattern with clear separation of concerns.

## Features

### Current Features

- **AI-Powered Commit Summarization**: Generate detailed markdown summaries for commits using LLM agents:
  - Processes commits in a range (from commit A to commit B)
  - Generates one markdown file per commit in a dedicated directory
  - Files are named with sequence number and commit hash for easy ordering and identification

## Requirements

- Python 3.12+
- Poetry (for dependency management)
- Git (for repository operations)

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd gitlab-ticker
```

2. Install dependencies using Poetry:
```bash
poetry install
```

3. Activate the virtual environment:
```bash
poetry shell
```

4. Configure environment variables:
   - Copy `.env.example` to `.env` (if it exists) or create a `.env` file
   - Set the required API keys (see Configuration section below)

## Usage

### Commit Validation and Summarization Script

The `validate_commits.py` script validates git repository parameters and optionally generates AI-powered commit summaries:

```bash
python validate_commits.py <repo_path> <branch_name> <commit_a> [commit_b] [--output OUTPUT_DIR] [--skip-summarization] [--skip-empty-merges]
```

**Parameters:**
- `repo_path`: Path to the git repository directory
- `branch_name`: Name of the branch to validate
- `commit_a`: Hash of the older commit (commit A)
- `commit_b`: (Optional) Hash of the newer commit (commit B). If not provided, defaults to the latest commit on the specified branch
- `--output`, `-o`: (Optional) Output directory path where commit summaries will be saved. Defaults to `./output`
- `--skip-summarization`: (Optional) Skip summarization and only validate parameters
- `--skip-empty-merges`: (Optional) Skip merge commits that contain no file changes. When enabled, merge commits without modifications are excluded from summarization, reducing output size and focusing on commits with actual code changes.

**Commit Summarization:**
When summarization is enabled (default), the script generates detailed markdown summaries for each commit in the range:
- Creates a `commits_summaries/` directory in the output directory
- Generates one markdown file per commit with the format: `{sequence:04d}_{commit_hash[:8]}.md`
  - Example: `0001_a1b2c3d4.md`, `0002_b2c3d4e5.md`, etc.
- Sequence numbers start at 1 and correspond to the commit order in the branch (oldest to newest)
- When `--skip-empty-merges` is used, filtered commits are excluded and sequence numbers are recalculated to maintain continuous numbering
- Each file contains the full markdown summary generated by the LLM agent

**Example:**
```bash
# Validate and generate summaries
python validate_commits.py /path/to/repo main abc123 def456

# Specify custom output directory
python validate_commits.py /path/to/repo main abc123 def456 --output ./my_summaries

# Skip empty merge commits (merge commits with no file changes)
python validate_commits.py /path/to/repo main abc123 def456 --skip-empty-merges

# Only validate without generating summaries
python validate_commits.py /path/to/repo main abc123 --skip-summarization
```

**Exit Codes:**
- `0`: All parameters are valid (and summaries generated if not skipped)
- `1`: Validation failed or summarization error with error message

## Configuration

### Environment Variables

The project uses environment variables for configuration. Create a `.env` file in the project root with the following variables:

**LLM Provider Configuration:**
- `LLM_PROVIDER`: Set to `"anthropic"` or `"openai"` to choose the LLM provider (default: `"anthropic"`)

**Anthropic API Configuration:**
- `ANTHROPIC_API_KEY`: Your Anthropic API key (required if using Anthropic)
- `ANTHROPIC_MODEL`: Model name to use (default: `"claude-3-5-sonnet-20241022"`)

**OpenAI API Configuration:**
- `OPENAI_API_KEY`: Your OpenAI API key (required if using OpenAI)
- `OPENAI_MODEL`: Model name to use (default: `"gpt-4-turbo-preview"`)

**LangSmith Observability Configuration:**
- `LANGCHAIN_API_KEY`: Your LangSmith API key (get it from https://smith.langchain.com/)
- `LANGCHAIN_TRACING_V2`: Set to `"true"` to enable LangSmith tracing (optional, but recommended)
- `LANGCHAIN_PROJECT`: Project name in LangSmith dashboard (optional, defaults to `"default"`)

### Observability with LangSmith

LangSmith provides comprehensive observability for LLM operations in this project. Once configured, it automatically traces:

- All LLM API calls (Anthropic Claude and OpenAI)
- Input messages and system prompts
- LLM responses and outputs
- Tool calls and function invocations
- Performance metrics (latency, token usage, costs)
- Errors and exceptions

**Setup:**
1. Sign up for a free account at https://smith.langchain.com/
2. Get your API key from the LangSmith dashboard
3. Add `LANGCHAIN_API_KEY` to your `.env` file
4. Set `LANGCHAIN_TRACING_V2=true` to enable tracing
5. Optionally set `LANGCHAIN_PROJECT` to organize traces in your dashboard

**Benefits:**
- **Debugging**: Inspect exact prompts and responses for each commit summarization
- **Monitoring**: Track performance and costs across all LLM operations
- **Optimization**: Identify slow or expensive operations
- **Quality Assurance**: Review generated summaries and improve prompts

The tracing works automatically with no code changes required - LangChain integrates seamlessly with LangSmith when the environment variables are set.

## Project Structure

The project follows a Domain-Driven Development (DDD) architecture:

```
gitlab_ticker/
  <domain_name>/
    domain/          # Domain entities and value objects
    repositories/    # Repository interfaces and implementations
    services/        # Business services
```

See `.cursorrules` for detailed architecture guidelines.

## Development

### Using Poetry

- Install dependencies: `poetry install`
- Add a dependency: `poetry add <package>`
- Add a development dependency: `poetry add --group dev <package>`
- Activate virtual environment: `poetry shell`
- Run commands in virtual environment: `poetry run <command>`
- Update dependencies: `poetry update`

### Code Standards

- All code, documentation, and comments must be in English
- Follow DDD architecture principles
- Write unit tests for domains, repositories, and services
- Keep README.md updated when adding new features
- **All code must be fully typed** with type hints (annotations)

### Code Quality Tools

The project uses **mypy** for type checking and **ruff** for linting and code formatting.

#### Type Checking with mypy

Check type correctness:
```bash
poetry run mypy .
```

All code must pass mypy type checks before committing. The project is configured with strict type checking enabled.

#### Linting and Formatting with ruff

Check code quality and style:
```bash
poetry run ruff check .
```

Format code:
```bash
poetry run ruff format .
```

**Important**: Every code change must be validated by both mypy and ruff before completion. Fix all errors and warnings before committing code.

## License

[Add license information here]

## Authors

- Pierre Rossin√®s <pierre.rossines@gmail.com>

