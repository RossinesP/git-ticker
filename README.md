# GitLab Ticker

A Python project for tracking and analyzing GitLab repositories using Domain-Driven Development (DDD) architecture.

## Overview

GitLab Ticker is designed to provide tools and services for working with GitLab repositories, including validation utilities and analysis capabilities. The project follows a clean architecture pattern with clear separation of concerns.

## Features

### Current Features

- **AI-Powered Commit Summarization**: Generate detailed markdown summaries for commits using LLM agents:
  - Processes commits in a range (from commit A to commit B) and generates one markdown file per commit
  - Generates a single unified summary of all changes from a development branch relative to a main branch (using `--dev-branch`)
  - Files are named with sequence number and commit hash for easy ordering and identification (commit range mode)
  - Console output for development branch diff summaries

## Requirements

- Python 3.12+
- Poetry (for dependency management)
- Git (for repository operations)

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd gitlab-ticker
```

2. Install dependencies using Poetry:
```bash
poetry install
```

3. Activate the virtual environment:
```bash
poetry shell
```

4. Configure environment variables:
   - Copy `.env.example` to `.env` (if it exists) or create a `.env` file
   - Set the required API keys (see Configuration section below)

## Usage

### Commit Validation and Summarization Script

The `validate_commits.py` script validates git repository parameters and optionally generates AI-powered commit summaries. It supports two modes:

#### Mode 1: Commit Range (Default)

Process commits between two specific commit hashes:

```bash
python validate_commits.py <repo_path> <branch_name> <commit_a> [commit_b] [--output OUTPUT_DIR] [--skip-summarization] [--skip-empty-merges]
```

**Parameters:**
- `repo_path`: Path to the git repository directory
- `branch_name`: Name of the branch
- `commit_a`: Hash of the older commit (commit A)
- `commit_b`: (Optional) Hash of the newer commit (commit B). If not provided, defaults to the latest commit on the specified branch
- `--output`, `-o`: (Optional) Output directory path where commit summaries will be saved. Defaults to `./output`
- `--skip-summarization`: (Optional) Skip summarization and only validate parameters
- `--skip-empty-merges`: (Optional) Skip merge commits that contain no file changes. When enabled, merge commits without modifications are excluded from summarization, reducing output size and focusing on commits with actual code changes.

#### Mode 2: Development Branch Diff

Generate a single summary of all changes between a development branch and the main branch:

```bash
python validate_commits.py <repo_path> <main_branch> --dev-branch <dev_branch> [--skip-summarization] [--max-diff-size MAX_SIZE] [--send-to-slack] [--slack-channel CHANNEL]
```

**Parameters:**
- `repo_path`: Path to the git repository directory
- `main_branch`: Name of the main branch (e.g., `main`, `master`)
- `--dev-branch`: Name of the development branch. When specified, the script finds the merge base (creation point) between the two branches and generates a single summary of all changes from the merge base to the latest commit on the development branch
- `--skip-summarization`: (Optional) Skip summarization and only validate parameters
- `--max-diff-size`: (Optional) Maximum diff size in characters before truncation (default: 50000)
- `--send-to-slack`: (Optional) Send the summary to a Slack channel (requires `--slack-channel`)
- `--slack-channel`: (Optional) Slack channel name without the # prefix (required if `--send-to-slack` is set)

**Note:** 
- When using `--dev-branch`, `commit_a` and `commit_b` are not required
- The script automatically finds the merge base (the commit where the development branch was created) and the latest commit on the development branch
- The summary is displayed in the console (not saved to files)
- This mode generates a single unified summary of all changes, rather than individual summaries per commit

**Commit Summarization:**
When summarization is enabled (default), the script generates detailed markdown summaries for each commit in the range:
- Creates a `commits_summaries/` directory in the output directory
- Generates one markdown file per commit with the format: `{sequence:04d}_{commit_hash[:8]}.md`
  - Example: `0001_a1b2c3d4.md`, `0002_b2c3d4e5.md`, etc.
- Sequence numbers start at 1 and correspond to the commit order in the branch (oldest to newest)
- When `--skip-empty-merges` is used, filtered commits are excluded and sequence numbers are recalculated to maintain continuous numbering
- Each file contains the full markdown summary generated by the LLM agent

**Examples:**

Commit Range Mode:
```bash
# Validate and generate summaries
python validate_commits.py /path/to/repo main abc123 def456

# Specify custom output directory
python validate_commits.py /path/to/repo main abc123 def456 --output ./my_summaries

# Skip empty merge commits (merge commits with no file changes)
python validate_commits.py /path/to/repo main abc123 def456 --skip-empty-merges

# Only validate without generating summaries
python validate_commits.py /path/to/repo main abc123 --skip-summarization
```

Development Branch Diff Mode:
```bash
# Generate a single summary of all changes from feature branch relative to main branch
python validate_commits.py /path/to/repo main --dev-branch feature/new-feature

# With custom max diff size
python validate_commits.py /path/to/repo main --dev-branch feature/new-feature --max-diff-size 100000

# Send summary to Slack channel
python validate_commits.py /path/to/repo main --dev-branch feature/new-feature \
  --send-to-slack --slack-channel team-updates
```

**Slack Integration:**

To send the summary to a Slack channel in dev-branch mode:

```bash
python validate_commits.py /path/to/repo main --dev-branch feature/new-feature \
  --send-to-slack --slack-channel general
```

**Requirements:**
- Set `SLACK_TOKEN` environment variable with your Slack Bot User OAuth Token
- The bot must be invited to the target channel
- Channel name should be without the # prefix (use `general` not `#general`)

**How to get a Slack token:**
1. Go to https://api.slack.com/apps
2. Create a new app or select an existing one
3. Navigate to "OAuth & Permissions"
4. Add the `chat:write` bot token scope
5. Install the app to your workspace
6. Copy the "Bot User OAuth Token" (starts with `xoxb-`)
7. Invite the bot to your channel: `/invite @your-bot-name`

**Note:** In dev-branch mode, the summary is displayed directly in the console. The `--output` and `--skip-empty-merges` options are not applicable in this mode.

**Exit Codes:**
- `0`: All parameters are valid (and summaries generated if not skipped)
- `1`: Validation failed or summarization error with error message

## Configuration

### Environment Variables

The project uses environment variables for configuration. Create a `.env` file in the project root with the following variables:

**LLM Provider Configuration:**
- `LLM_PROVIDER`: Set to `"anthropic"` or `"openai"` to choose the LLM provider (default: `"anthropic"`)

**Anthropic API Configuration:**
- `ANTHROPIC_API_KEY`: Your Anthropic API key (required if using Anthropic)
- `ANTHROPIC_MODEL`: Model name to use (default: `"claude-3-5-sonnet-20241022"`)

**OpenAI API Configuration:**
- `OPENAI_API_KEY`: Your OpenAI API key (required if using OpenAI)
- `OPENAI_MODEL`: Model name to use (default: `"gpt-4-turbo-preview"`)

**Slack Notification Configuration:**
- `SLACK_TOKEN`: Your Slack Bot User OAuth Token (required for Slack notifications)

**LangSmith Observability Configuration:**
- `LANGCHAIN_API_KEY`: Your LangSmith API key (get it from https://smith.langchain.com/)
- `LANGCHAIN_TRACING_V2`: Set to `"true"` to enable LangSmith tracing (optional, but recommended)
- `LANGCHAIN_PROJECT`: Project name in LangSmith dashboard (optional, defaults to `"default"`)

### Observability with LangSmith

LangSmith provides comprehensive observability for LLM operations in this project. Once configured, it automatically traces:

- All LLM API calls (Anthropic Claude and OpenAI)
- Input messages and system prompts
- LLM responses and outputs
- Tool calls and function invocations
- Performance metrics (latency, token usage, costs)
- Errors and exceptions

**Setup:**
1. Sign up for a free account at https://smith.langchain.com/
2. Get your API key from the LangSmith dashboard
3. Add `LANGCHAIN_API_KEY` to your `.env` file
4. Set `LANGCHAIN_TRACING_V2=true` to enable tracing
5. Optionally set `LANGCHAIN_PROJECT` to organize traces in your dashboard

**Benefits:**
- **Debugging**: Inspect exact prompts and responses for each commit summarization
- **Monitoring**: Track performance and costs across all LLM operations
- **Optimization**: Identify slow or expensive operations
- **Quality Assurance**: Review generated summaries and improve prompts

The tracing works automatically with no code changes required - LangChain integrates seamlessly with LangSmith when the environment variables are set.

## Project Structure

The project follows a Domain-Driven Development (DDD) architecture:

```
gitlab_ticker/
  <domain_name>/
    domain/          # Domain entities and value objects
    repositories/    # Repository interfaces and implementations
    services/        # Business services
```

See `.cursorrules` for detailed architecture guidelines.

## Development

### Using Poetry

- Install dependencies: `poetry install`
- Add a dependency: `poetry add <package>`
- Add a development dependency: `poetry add --group dev <package>`
- Activate virtual environment: `poetry shell`
- Run commands in virtual environment: `poetry run <command>`
- Update dependencies: `poetry update`

### Code Standards

- All code, documentation, and comments must be in English
- Follow DDD architecture principles
- Write unit tests for domains, repositories, and services
- Keep README.md updated when adding new features
- **All code must be fully typed** with type hints (annotations)

### Code Quality Tools

The project uses **ty** for type checking and **ruff** for linting and code formatting.

#### Type Checking with ty

Check type correctness:
```bash
poetry run ty check
```

All code must pass ty type checks before committing. The project is configured with strict type checking enabled.

#### Linting and Formatting with ruff

Check code quality and style:
```bash
poetry run ruff check .
```

Format code:
```bash
poetry run ruff format .
```

**Important**: Every code change must be validated by both ty and ruff before completion. Fix all errors and warnings before committing code.

## License

[Add license information here]

## Authors

- Pierre Rossin√®s <pierre.rossines@gmail.com>

